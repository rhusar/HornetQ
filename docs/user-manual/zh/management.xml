<?xml version="1.0" encoding="UTF-8"?>
<!-- ============================================================================= -->
<!-- Copyright © 2009 Red Hat, Inc. and others.                                    -->
<!--                                                                               -->
<!-- The text of and illustrations in this document are licensed by Red Hat under  -->
<!-- a Creative Commons Attribution–Share Alike 3.0 Unported license ("CC-BY-SA"). -->
<!--                                                                               -->
<!-- An explanation of CC-BY-SA is available at                                    -->
<!--                                                                               -->
<!--            http://creativecommons.org/licenses/by-sa/3.0/.                    -->
<!--                                                                               -->
<!-- In accordance with CC-BY-SA, if you distribute this document or an adaptation -->
<!-- of it, you must provide the URL for the original version.                     -->
<!--                                                                               -->
<!-- Red Hat, as the licensor of this document, waives the right to enforce,       -->
<!-- and agrees not to assert, Section 4d of CC-BY-SA to the fullest extent        -->
<!-- permitted by applicable law.                                                  -->
<!-- ============================================================================= -->
<chapter id="management">
   <title>管理</title>
   <para>HornetQ拥有套丰富的管理接口。用户使用这些接口可以修改服务器配置、创建新的资源（如队列和
      话题）、检查这些资源（如队列中有多少消息）并进行管理（从队列中删除消息）。这样用户可以
      <emphasis>管理</emphasis>HornetQ。另外，客户还可以订阅管理通知。</para>
   <para>有三种方式管理HornetQ：</para>
   <itemizedlist>
      <listitem>
         <para>使用JMX -- JMX是标准的Java应用程序管理方式。</para>
      </listitem>
      <listitem>
         <para>使用核心接口 -- 管理操作通过<emphasis>核心消息</emphasis>的方法发向HornetQ服
         务。</para>
      </listitem>
      <listitem>
         <para>使用JMS接口 -- 管理操作通过<emphasis>JMS消息</emphasis>的方式发向HornetQ服务器。</para>
      </listitem>
   </itemizedlist>
   <para>虽然有三种方式，但它们提供相同的功能。使用JMX方法能完成的功能使用核心接口或JMS接口都可以完成。</para>
   <para>根据不同的应用环境来选择最适当的方式。</para>
   <section>
      <title>管理接口API</title>
      <para>不管使用哪种方式，管理接口都是一样的。</para>
      <para>对于每个<emphasis>被管理的资源</emphasis>都有一个Java的接口提供可使用的操作。</para>
      <para>HornetQ的管理接口分布在2个包中：</para>
      <itemizedlist>
         <listitem>
            <para><emphasis>核心</emphasis>资源的管理接口在 <literal
                  >org.hornetq.api.core.management</literal>包中。</para>
         </listitem>
         <listitem>
            <para><emphasis>JMS</emphasis>资源的管理接口在 <literal
                  >org.hornetq.api.jms.management</literal>包中。</para>
         </listitem>
      </itemizedlist>
      <para>调用<emphasis>管理操作</emphasis>的方法由所使用是方式是JMX、核心消息还是JMS
         消息来决定。</para>
      <note>
         <para>一小部分的管理接口需要一个<literal>过滤器</literal>参数来选择需要的消息。
            如果要求<emphasis>所有的消息</emphasis>，传递该参数时使用<literal>
            null</literal>或者一个空的字符串即可。</para>
      </note>
      <section>
         <title>核心管理接口</title>
         <para>HornetQ定义了一套对核心资源的管理接口。关于它们的详细说明请参见相应的javadoc。
            下面是对它们的概述：</para>
         <section>
            <title>核心服务器管理</title>
            <itemizedlist>
               <listitem>
                  <para>队列的列表、创建、部署与删除</para>
                  <para><literal>getQueueNames()</literal> method方法用来列出所有已经部署的队列。</para>
                  <para>在<literal>HornetQServerControl</literal> （ObjectName <literal
                        >org.hornetq:module=Core,type=Server</literal>或资源名<literal
                        >core.server</literal>）上有队列创建或删除的方法，它们是
                        <literal>createQueue()</literal>、<literal>deployQueue()</literal>和
                        <literal>destroyQueue()</literal>。</para>
                  <para>如果队列已经存在，那么<literal>createQueue</literal>方法调用会出错，而
                        <literal>deployQueue</literal>方法调用没有任何作用。</para>
               </listitem>
               <listitem>
                  <para>暂停与恢复队列</para>
                  <para><literal>QueueControl</literal>可用来暂停与恢复队列。如果一个队列被暂停，它
                     虽然可以继续接收消息但是不传递消息；当被恢复时，队列又会开始传递消息。
                  </para>
               </listitem>
               <listitem>
                  <para>远程连接的列表与关闭</para>
                  <para><literal>listRemoteAddresses()</literal>方法可以用来列出客户端的远程地址。
                     还可以使用<literal>closeConnectionsForAddress()</literal>方法来关闭
                     与该地址相关的远程连接。</para>
                  <para>另外，使用<literal>listConnectionIDs()</literal>方法可以列出连接ID，
                     使用<literal>listSessions()</literal>方法可以列出与一个连接ID相关的所有
                     会话（session）。</para>
               </listitem>
               <listitem>
                  <para>事务的手动操作（heuristic operations）</para>
                  <para>当服务器由于故障而重新启动时，可能造成一些事务没有完成而需要人工干预。
                        <literal>listPreparedTransactions()</literal>方法可以列出所有处于
                     准备（prepared）状态的事务（事务是用Base64字符串的形式列出）。如果要提交或回滚，
                     可以使用<literal>commitPreparedTransaction()</literal>方法或
                     <literal>rollbackPreparedTransaction()</literal>方法。采用启发式
                    （heuristic）完成的事务可以用<literal>listHeuristicCommittedTransactions()</literal>
                     方法和<literal>listHeuristicRolledBackTransactions</literal>方法列出。</para>
               </listitem>
               <listitem>
                  <para>打开和重置消息计数器</para>
                  <para>消息计数器可以用<literal>enableMessageCounters()</literal>方法打开，用
                        <literal>disableMessageCounters()</literal>方法关闭。如果要重置消息计数器，
                        可以使用<literal>resetAllMessageCounters()</literal>方法和
                        <literal>resetAllMessageCounterHistories()</literal>方法。</para>
               </listitem>
               <listitem>
                  <para>获得服务器的配置和属性</para>
                  <para><literal>HornetQServerControl</literal>提供了访问HornetQ服务器所有属性
                     的方法（例如<literal>getVersion()</literal>方法可以得到服务器的版本，等等）。 </para>
               </listitem>
            </itemizedlist>
         </section>
         <section>
            <title>核心地址的管理</title>
            <para>核心地址可以通过<literal>AddressControl</literal>类进行访问（ObjectName
                  是 <literal>org.hornetq:module=Core,type=Address,name="&lt;the
                  address name&gt;"</literal>或者资源名 <literal>core.address.&lt;the
                  address name&gt;</literal>）。</para>
            <itemizedlist>
               <listitem>
                  <para>修改地址的角色和权限。</para>
                  <para>你可以使用<literal>addRole()</literal>方法或<literal>removeRole()</literal>
                  方法添加或删除地址的角色。用<literal>getRoles()</literal>方法可以列出一个地址的所有角色。</para>
               </listitem>
            </itemizedlist>
         </section>
         <section>
            <title>核心队列的管理</title>
            <para>管理接口中的一大部分是管理核心队列的。<literal>QueueControl</literal>类定义了核心队列的管理
               接口（ObjectName <literal>org.hornetq:module=Core,type=Queue,address="&lt;绑定地址
                  address&gt;",name="&lt;队列名&gt;"</literal> 或资源名 <literal
                  >core.queue.&lt;队列名&gt;</literal>）。</para>
            <para>绝大部分的队列管理方法需要一个消息ID参数（如删除一个消息）或一个过滤器参数（如将具有某个
               属性值的所有消息设置为过期）。</para>
            <itemizedlist>
               <listitem>
                  <para>消息的过期，发向死信地址及删除</para>
                  <para><literal>expireMessages()</literal>方法可以使消息过期。如果设置了一个过期地址，
                     这些消息会被发到过期地址。否则这些消息会被丢弃。<literal>setExpiryAddress()</literal>
                     方法可以用来设置队列的过期地址。</para>
                  <para>消息可以用<literal>sendMessagesToDeadLetterAddress()</literal>方法发送到
                     一个死信地址。它返回发到这个死信地址的消息的数量。如果没有设置死信地址，那么消息就会从队列中
                     删除。用<literal>setDeadLetterAddress()</literal>方法可以设置队列的死信地址。</para>
                  <para>消息还可以从一个队列转移到另一个队列。其方法是
                        <literal>moveMessages()</literal>。</para>
               </listitem>
               <listitem>
                  <para>消息的列表与删除</para>
                  <para>用<literal>listMessages()</literal>方法可以列出一个队列中的所有消息。这个方法
                        返回的是一个<literal>Map</literal>的数组。每一个Map对应一个消息。</para>
                  <para>消息可以用<literal>removeMessages()</literal>方法删除。如果是使用消息ID，
                        返回的是一个布尔常量；如果是用过滤器，则返回的
                        是删除的消息数量。在使用过滤器来删除过滤的消息时，如果传入一个空字符串则表示要删除
                        所有的消息。</para>
               </listitem>
               <listitem>
                  <para>消息计数</para>
                  <para>一个队列中的消息数可以用<literal>getMessageCount()</literal>方法获得。
                        此外，<literal>countMessages()</literal>方法可以返回队列中与一
                        个<emphasis>过滤器</emphasis>匹配的消息数量。</para>
               </listitem>
               <listitem>
                  <para>修改消息的优先级</para>
                  <para>用<literal>changeMessagesPriority()</literal>方法可以改变消息的优先级。
                        该方法如果带一个消息ID参数，返回一个布尔常量；如果带一个过滤器参数，返回优先级
                        被更新的消息的数量。</para>
               </listitem>
               <listitem>
                  <para>消息计数器</para>
                  <para>用<literal>listMessageCounter()方法和<literal>
                        listMessageCounterHistory()</literal>方法可以列出一个队列的消息计数器。
                        （参见 <xref linkend="management.message-counters"/>）。消息计数器还可以
                       用<literal>resetMessageCounter()</literal>方法重置。</para>
               </listitem>
               <listitem>
                  <para>获得队列的属性</para>
                  <para>通过<literal>QueueControl</literal>可以获得核心队列的属性（例如用
                     <literal>getFilter()</literal>方法可以得到队列的
                     过滤器，<literal>isDurable()</literal>方法可以知道队列是否是持久的队列等等）。</para>
               </listitem>
               <listitem>
                  <para>暂停和恢复队列</para>
                     <literal>QueueControl</literal>可用来暂停与恢复队列。如果一个队列被暂停，它
                     虽然可以继续接收消息但是不传递消息；当被恢复时，队列又会开始传递消息。<para>
               </listitem>
            </itemizedlist>
         </section>
         <section>
            <title>其它核心资源的管理</title>
            <para>HornetQ允许用户启动或停止其远程资源（接收器，转发器，桥，等等）。这样可以使服务器暂停工作
               而不需要完全停止服务器（比如可以临时对服务器进行一些离线操作，像对一些事务的处理）。这些资源有：</para>
            <itemizedlist>
               <listitem>
                  <para>接收器</para>
                  <para>用<literal>AcceptorControl</literal>类（ObjectName <literal
                        >org.hornetq:module=Core,type=Acceptor,name="&lt;接收器名
                        &gt;"</literal> 或资源名 <literal>core.acceptor.&lt;地址名
                        &gt;</literal>）的<literal>start()</literal>方法启动，用<literal>
                        stop()</literal>方法停止。接收器的参数可以通过<literal>AcceptorControl</literal>
                        的属性获得。（参见 <xref
                        linkend="configuring-transports.acceptors"/>）。</para>
               </listitem>
               <listitem>
                  <para>转发器</para>
                  <para>用<literal>DivertControl</literal>（ObjectName是 <literal
                        >org.hornetq:module=Core,type=Divert,name=&lt;转发器名&gt;</literal>
                        或资源名<literal>core.divert.&lt;转发器&gt;</literal>）类的
                        <literal>start()</literal>方法可以启动，用<literal>stop()</literal>方法可以停止。
                        通过<literal>DivertControl</literal>还可以获得转发器的各种属性。（参见 <xref
                        linkend="diverts"/>）。</para>
               </listitem>
               <listitem>
                  <para>桥</para>
                  <para>桥可以通过<literal>BridgeControl</literal>类（ObjectName <literal
                        >org.hornetq:module=Core,type=Bridge,name="&lt;桥的名字
                        &gt;"</literal> 或资源名 <literal>core.bridge.&lt;桥的名字
                        &gt;</literal>）的<literal>start()</literal>
                        方法启动，用<literal>stop()</literal>方法停止。它的属性可以通过
                        <literal>BridgeControl</literal>的属性获得（参见
                        <xref linkend="core-bridges"/>）。</para>
               </listitem>
               <listitem>
                  <para>广播组</para>
                  <para>广播组可以通过<literal>BroadcastGroupControl</literal>类（ObjectName <literal
                        >org.hornetq:module=Core,type=BroadcastGroup,name="&lt;广播组名
                        &gt;"</literal> 或者资源名 <literal
                        >core.broadcastgroup.&lt;广播组名&gt;</literal>)的<literal>
                        start()</literal>方法启动，用<literal>stop()</literal>方法停止。
                        它的属性也可以通过<literal
                        >BroadcastGroupControl</literal>的属性获得（参见<xref
                        linkend="clusters.broadcast-groups"/>）。</para>
               </listitem>
               <listitem>
                  <para>发现组</para>
                  <para>发现组可以通过<literal>DiscoveryGroupControl</literal>类
                        （ObjectName <literal>org.hornetq:module=Core,type=DiscoveryGroup,
                        name="&lt;发现组名&gt;"</literal> 或资源名<literal>core.discovery.&lt;
                        发现组名&gt;</literal>）的
                        <literal>start()</literal>方法启动，用<literal>stop()</literal>方法停止。
                        它的参数可以通过<literal>DiscoveryGroupControl</literal>的属性获得（参见
                        <xref linkend="clusters.discovery-groups"/>）。</para>
               </listitem>
               <listitem>
                  <para>集群连接</para>
                  <para>集群连接可以通过<literal>ClusterConnectionControl</literal>类（
                        ObjectName <literal
                        >org.hornetq:module=Core,type=ClusterConnection,name="&lt;集群连接名
                        &gt;"</literal> 或资源名 <literal
                        >core.clusterconnection.&lt;集群连接名&gt;</literal>）的<literal>
                        start()</literal>方法启动，用<literal>stop()</literal>方法停止。
                        它的参数可以通过<literal
                        >ClusterConnectionControl</literal>的属性来获得（参见
                        <xref linkend="clusters.cluster-connections"/>）。</para>
               </listitem>
            </itemizedlist>
         </section>
      </section>
      <section>
         <title>JMS管理接口</title>
         <para>HornetQ定义了一套JMS管理接口来管理JMS的<emphasis>可管理的对象</emphasis> 
              （例如JMS队列，话题及连接工厂）。</para>
         <section>
            <title>JMS服务器管理</title>
            <para><literal>JMSServerControl</literal>类（ObjectName <literal
                  >org.hornetq:module=JMS,type=Server</literal> 或资源名<literal
                  >jms.server</literal>）用来创建JMS资源（连接工厂和目标）。</para>
            <itemizedlist>
               <listitem>
                  <para>列表、创建、删除连接工厂</para>
                  <para>使用<literal>getConnectionFactoryNames()</literal> 方法可以列出部署的连接工厂的
                        名字。</para>
                  <para>用<literal>createConnectionFactory()</literal>方法和<literal
                        >destroyConnectionFactory()</literal>方法能创建和删除JMS连接工厂。
                     这些连接工厂都与JNDI绑定以便于客户端来查找。如果是在图形介面下创建连接工厂，在广本框内输入
                     有关的传输参数时可使用一组用逗号隔开的键－值对（例如<literal>key1=10, key2="value", key3=false</literal>）。
                     如果需要定义多个传输，你需要将每个传输的参数对用大括号括起来，例如<literal>{key=10}, {key=20}</literal>。
                     第一个<literal>key</literal>属于第一个传输配置，第二个<literal>key</literal>属于第二个传输配置。
                     （有关传输的各种参数参见<xref linkend="configuring-transports"/>）。</para>
               </listitem>
               <listitem>
                  <para>列表、创建与删除队列</para>
                  <para><literal>getQueueNames()</literal>方法可以获得部署的JMS队列的名字列表。</para>
                  <para>JMS队列可以用<literal>createQueue()</literal>方法创建，用<literal>destroyQueue()</literal>方法删除。
                     创建的队列都绑定到JNDI以便JMS客户端可以查找。</para>
               </listitem>
               <listitem>
                  <para>列表、创建与删除话题（topic）</para>
                  <para><literal>getTopicNames()</literal>方法可以获得部署的JMS话题名字。</para>
                  <para>JMS话题可以用<literal>createTopic()</literal>方法来创建，用<literal>destroyTopic()</literal>方法来删除。
                     创建的话题都绑定到JNDI以便客户端查找。</para>
               </listitem>
               <listitem>
                  <para>远程连接的列表与关闭</para>
                  <para>用<literal>listRemoteAddresses()</literal>方法可以获得JMS客户端的远程地址。
                     还可以用<literal>closeConnectionsForAddress()</literal>方法关闭与某个远程地址相关联的连接。</para>
                  <para>另外，<literal>listConnectionIDs()</literal>方法可以列出连接的ID，
                     而<literal>listSessions()</literal>方法可以列出一个给定的连接ID的所有会话（session）。</para>
               </listitem>
            </itemizedlist>
         </section>
         <section>
            <title>JMS连接工厂的管理</title>
            <para>使用类（ObjectName <literal>org.hornetq:module=JMS,type=ConnectionFactory,
                  name="&lt;连接工厂名&gt;"</literal>或者资源名<literal>jms.connectionfactory.&lt;
                  连接工厂名&gt;</literal>）可以管理JMS的连接工厂。</para>
            <itemizedlist>
               <listitem>
                  <para>获得连接工厂的属性</para>
                  <para><literal>ConnectionFactoryControl</literal>类可以用来获得连接工厂的属性（
                     例如<literal>getConsumerWindowSize()</literal>方法可以获得接收者流控制的窗口大小，
                     <literal>isBlockOnNonDurableSend()</literal>方法可以知道从这个连接工厂创建的发送
                     者是否采用阻塞方式发送非持久的消息，等等）。</para>
               </listitem>
            </itemizedlist>
         </section>
         <section>
            <title>JMS队列管理</title>
            <para>使用<literal>JMSQueueControl</literal>类（ObjectName <literal>org.hornetq:module=JMS,
                  type=Queue,name="&lt;队列名&gt;"</literal>或资源名 <literal>jms.queue.&lt;队列名
                  &gt;</literal>可以管理JMS队列。</para>
            <para><emphasis>JMS队列的管理操作与核心队列的管理十分相似。</emphasis></para>
            <itemizedlist>
               <listitem>
                  <para>过期，发送到死信地址和移动消息</para>
                  <para>可以使用<literal>expireMessages()</literal>方法将队列中的消息设成过期消息。
                        如果配置有过期地址，消息就会被发到过期地址。过期地址可以用
                     <literal>setExpiryAddress()</literal>方法来设定。</para>
                  <para>使用<literal>sendMessagesToDeadLetterAddress()</literal>方法可以将消息发送到死信地址。
                     它返回发送到死信地址消息的数量。如果没有设定死信地址，那么消息会被丢弃。使用
                     <literal>setDeadLetterAddress()</literal>方法可以设定队列的死信地址。</para>
                  <para><literal>moveMessages()</literal>方法将消息从一个队列移动到另一个队列。</para>
               </listitem>
               <listitem>
                  <para>列表与删除消息</para>
                  <para>使用<literal>listMessages()</literal>方法可以列出一个队列中的所有消息。它返回的是一个
                        Map的数组。每一个Map对应一个消息。</para>
                  <para>使用<literal>removeMessages()</literal>方法可以从队列中删除消息。如果带的参数是消息ID，
                        返回的是一个布尔常是；如果带的参数是一个过滤器，则返回删除的消息数。带有过滤器参数的<literal
                        >removeMessages()</literal>方法只删除过滤器选择的消息。如果些参数是一个空字符串，那么将
                        删除所有的消息。</para>
               </listitem>
               <listitem>
                  <para>消息计数</para>
                  <para>使用<literal>getMessageCount()</literal>方法可以得到队列中的消息数。另外，方法
                        <literal>countMessages()</literal>可以得到队列中所有与<emphasis>过滤器</emphasis>相匹配的消息数。</para>
               </listitem>
               <listitem>
                  <para>修改消息的优先级</para>
                  <para>消息的优先级可以用<literal>changeMessagesPriority()</literal>方法修改。如果是带一个消
                        息ID参数，它返回的是一个布尔常量；如果是带一个过滤器参数，则它返回的是优先级更新了的消息数。</para>
               </listitem>
               <listitem>
                  <para>消息计数器</para>
                  <para><literal>listMessageCounter()</literal>方法和<literal >listMessageCounterHistory()</literal>
                        方法可以用来列出队列中的所有消息计数器。（参见 <xref
                        linkend="management.message-counters"/>）。</para>
               </listitem>
               <listitem>
                  <para>获取队列的属性</para>
                  <para><literal>JMSQueueControl</literal>类可以用来获取JMS队列的设置参数（例如方法<literal>isTemporary()</literal>
                     可以判断队列是否为临时的，方法<literal>isDurable()</literal>可以判断队列是否为持久的等等）。</para>
               </listitem>
               <listitem>
                  <para>队列的暂停与恢复</para>
                  <para><literal>JMSQueueControl</literal>可以暂停一个队列或恢复一个队列。
                     如果一个队列被暂停，它虽然可以继续接收消息但是不传递消息；
                     当被恢复时，队列又会开始传递消息。</para>
               </listitem>
            </itemizedlist>
         </section>
         <section>
            <title>JMS话题（Topic）的管理</title>
            <para>JMS话题的管理是通过<literal>TopicControl</literal>类（
               the ObjectName <literal>org.hornetq:module=JMS,type=Topic,name="&lt;话题名&gt;"</literal>
               或资源名 <literal>jms.topic.&lt;话题名&gt;</literal>）。</para>
            <itemizedlist>
               <listitem>
                  <para>订阅和消息的列表</para>
                  <para><literal>listAllSubscriptions()</literal>、<literal
                        >listDurableSubscriptions()</literal>、 <literal
                        >listNonDurableSubscriptions()</literal>方法可以列出话题的不同订阅。
                     这些方法都返回<literal>Object</literal>数组，表示订阅的细节（如订阅名，
                     客户ID，持久性，消息计数等）。用<literal
                        >listMessagesForSubscription()</literal>方法可以列出一个订阅上的JMS消息。</para>
               </listitem>
               <listitem>
                  <para>删除订阅</para>
                  <para>持久性订阅可以使用<literal>dropDurableSubscription()</literal>方法来删除。</para>
               </listitem>
               <listitem>
                  <para>订阅消息计数</para>
                  <para><literal>countMessagesForSubscription()</literal>方法可以得到一个订阅上面所持有
                     的消息数（还可带一个消息选择器来得出有多少消息与之匹配）。</para>
               </listitem>
            </itemizedlist>
         </section>
      </section>
   </section>
   <section id="management.jmx">
      <title>Using Management Via JMX</title>
      <para>HornetQ can be managed using <ulink
            url="http://java.sun.com/javase/technologies/core/mntr-mgmt/javamanagement/"
         >JMX</ulink>. </para>
      <para>The management API is exposed by HornetQ using MBeans interfaces. HornetQ registers its
         resources with the domain <literal>org.hornetq</literal>.</para>
      <para>For example, the <literal>ObjectName</literal> to manage a JMS Queue <literal
            >exampleQueue</literal> is:</para>
      <programlisting>
   org.hornetq:module=JMS,type=Queue,name="exampleQueue"   
      </programlisting>
      <para>and the MBean is:</para>
      <programlisting>
   org.hornetq.api.jms.management.JMSQueueControl   
      </programlisting>
      <para>The MBean's <literal>ObjectName</literal> are built using the helper class <literal
            >org.hornetq.api.core.management.ObjectNameBuilder</literal>. You can also use <literal
            >jconsole</literal> to find the <literal>ObjectName</literal> of the MBeans you want to
         manage. </para>
      <para>Managing HornetQ using JMX is identical to management of any Java Applications using
         JMX. It can be done by reflection or by creating proxies of the MBeans.</para>
      <section id="management.jmx.configuration">
         <title>Configuring JMX</title>
         <para>By default, JMX is enabled to manage HornetQ. It can be disabled by setting <literal
               >jmx-management-enabled</literal> to <literal>false</literal> in <literal
               >hornetq-configuration.xml</literal>:</para>
         <programlisting>
&lt;!-- false to disable JMX management for HornetQ --&gt;
&lt;jmx-management-enabled&gt;false&lt;/jmx-management-enabled&gt;            
         </programlisting>
         <para>If JMX is enabled, HornetQ can be managed locally using <literal>jconsole</literal>.
            Remote connections to JMX are not enabled by default for security reasons. Please refer
            to <ulink url="http://java.sun.com/j2se/1.5.0/docs/guide/management/agent.html#remote"
               >Java Management guide</ulink> to configure the server for remote management (system
            properties must be set in <literal>run.sh</literal> or <literal>run.bat</literal>
            scripts).</para>
         <para>By default, HornetQ server uses the JMX domain "org.hornetq". To manage several
            HornetQ servers from the <emphasis>same</emphasis> MBeanServer, the JMX domain can be
            configured for each individual HornetQ server by setting <literal>jmx-domain</literal>
            in <literal>hornetq-configuration.xml</literal>: </para>
         <programlisting>
&lt;!-- use a specific JMX domain for HornetQ MBeans -->
&lt;jmx-domain>my.org.hornetq&lt;/jmx-domain>            
         </programlisting>
         <section>
            <title>MBeanServer configuration</title>
            <para>When HornetQ is run in standalone, it uses the Java Virtual Machine's <literal
                  >Platform MBeanServer</literal> to register its MBeans. This is configured in
               JBoss Microcontainer Beans file (see <xref
                  linkend="server.microcontainer.configuration"/>):</para>
            <programlisting>&lt;!-- MBeanServer --&gt;
&lt;bean name="MBeanServer" class="javax.management.MBeanServer"&gt;
   &lt;constructor factoryClass="java.lang.management.ManagementFactory"
                         factoryMethod="getPlatformMBeanServer" /&gt;
&lt;/bean&gt;            
            </programlisting>
            <para>When it is integrated in JBoss AS 5+, it uses the Application Server's own MBean
               Server so that it can be managed using AS 5's jmx-console:</para>
            <programlisting>&lt;!-- MBeanServer --&gt;
&lt;bean name="MBeanServer" class="javax.management.MBeanServer"&gt;
   &lt;constructor factoryClass="org.jboss.mx.util.MBeanServerLocator"
                         factoryMethod="locateJBoss" /&gt;
&lt;/bean&gt;            
            </programlisting>
         </section>
      </section>
      <section>
         <title>Example</title>
         <para>See <xref linkend="examples.jmx"/> for an example which shows how to use a remote
            connection to JMX and MBean proxies to manage HornetQ.</para>
      </section>
   </section>
   <section>
      <title>Using Management Via Core API</title>
      <para>The core management API in HornetQ is called by sending Core messages to a special
         address, the <emphasis>management address</emphasis>.</para>
      <para><emphasis>Management messages</emphasis> are regular Core messages with well-known
         properties that the server needs to understand to interact with the management API:</para>
      <itemizedlist>
         <listitem>
            <para>The name of the managed resource</para>
         </listitem>
         <listitem>
            <para>The name of the management operation</para>
         </listitem>
         <listitem>
            <para>The parameters of the management operation</para>
         </listitem>
      </itemizedlist>
      <para>When such a management message is sent to the management address, HornetQ server will
         handle it, extract the information, invoke the operation on the managed resources and send
         a <emphasis>management reply</emphasis> to the management message's reply-to address
         (specified by <literal>ClientMessageImpl.REPLYTO_HEADER_NAME</literal>). </para>
      <para>A <literal>ClientConsumer</literal> can be used to consume the management reply and
         retrieve the result of the operation (if any) stored in the reply's body. For portability,
         results are returned as a <ulink url="http://json.org">JSON</ulink> String rather than Java
         Serialization (the <literal>org.hornetq.api.core.management.ManagementHelper</literal> can
         be used to convert the JSON string to Java objects).</para>
      <para>These steps can be simplified to make it easier to invoke management operations using
         Core messages:</para>
      <orderedlist>
         <listitem>
            <para>Create a <literal>ClientRequestor</literal> to send messages to the management
               address and receive replies</para>
         </listitem>
         <listitem>
            <para>Create a <literal>ClientMessage</literal></para>
         </listitem>
         <listitem>
            <para>Use the helper class <literal
                  >org.hornetq.api.core.management.ManagementHelper</literal> to fill the message
               with the management properties</para>
         </listitem>
         <listitem>
            <para>Send the message using the <literal>ClientRequestor</literal></para>
         </listitem>
         <listitem>
            <para>Use the helper class <literal
                  >org.hornetq.api.core.management.ManagementHelper</literal> to retrieve the
               operation result from the management reply</para>
         </listitem>
      </orderedlist>
      <para>For example, to find out the number of messages in the core queue <literal
            >exampleQueue</literal>:</para>
      <programlisting>
   ClientSession session = ...
   ClientRequestor requestor = new ClientRequestor(session, "jms.queue.hornetq.management");
   ClientMessage message = session.createMessage(false);
   ManagementHelper.putAttribute(message, "core.queue.exampleQueue", "messageCount");
   ClientMessage reply = requestor.request(m);
   int count = (Integer) ManagementHelper.getResult(reply);
   System.out.println("There are " + count + " messages in exampleQueue");
      </programlisting>
      <para>Management operation name and parameters must conform to the Java interfaces defined in
         the <literal>management</literal> packages.</para>
      <para>Names of the resources are built using the helper class <literal
            >org.hornetq.api.core.management.ResourceNames</literal> and are straightforward
            (<literal>core.queue.exampleQueue</literal> for the Core Queue <literal
            >exampleQueue</literal>, <literal>jms.topic.exampleTopic</literal> for the JMS Topic
            <literal>exampleTopic</literal>, etc.).</para>
      <section id="management.core.configuration">
         <title>Configuring Core Management</title>
         <para>The management address to send management messages is configured in <literal
               >hornetq-configuration.xml</literal>:</para>
         <programlisting>
   &lt;management-address&gt;jms.queue.hornetq.management&lt;/management-address&gt;
         </programlisting>
         <para>By default, the address is <literal>jms.queue.hornetq.management</literal> (it is
            prepended by "jms.queue" so that JMS clients can also send management messages).</para>
         <para>The management address requires a <emphasis>special</emphasis> user permission
               <literal>manage</literal> to be able to receive and handle management messages. This
            is also configured in hornetq-configuration.xml:</para>
         <programlisting>
   &lt;!-- users with the admin role will be allowed to manage --&gt; 
   &lt;!-- HornetQ using management messages        --&gt;
   &lt;security-setting match="jms.queue.hornetq.management"&gt;
      &lt;permission type="manage" roles="admin" /&gt;
   &lt;/security-setting&gt;
         </programlisting>
      </section>
   </section>
   <section id="management.jms">
      <title>Using Management Via JMS</title>
      <para>Using JMS messages to manage HornetQ is very similar to using core API.</para>
      <para>An important difference is that JMS requires a JMS queue to send the messages to
         (instead of an address for the core API).</para>
      <para>The <emphasis>management queue</emphasis> is a special queue and needs to be
         instantiated directly by the client:</para>
      <programlisting>
   Queue managementQueue = HornetQJMSClient.createQueue("hornetq.management");
      </programlisting>
      <para>All the other steps are the same than for the Core API but they use JMS API
         instead:</para>
      <orderedlist>
         <listitem>
            <para>create a <literal>QueueRequestor</literal> to send messages to the management
               address and receive replies</para>
         </listitem>
         <listitem>
            <para>create a <literal>Message</literal></para>
         </listitem>
         <listitem>
            <para>use the helper class <literal
                  >org.hornetq.api.jms.management.JMSManagementHelper</literal> to fill the message
               with the management properties</para>
         </listitem>
         <listitem>
            <para>send the message using the <literal>QueueRequestor</literal></para>
         </listitem>
         <listitem>
            <para>use the helper class <literal
                  >org.hornetq.api.jms.management.JMSManagementHelper</literal> to retrieve the
               operation result from the management reply</para>
         </listitem>
      </orderedlist>
      <para>For example, to know the number of messages in the JMS queue <literal
            >exampleQueue</literal>:</para>
      <programlisting>
   Queue managementQueue = HornetQJMSClient.createQueue("hornetq.management");   
   
   QueueSession session = ...      
   QueueRequestor requestor = new QueueRequestor(session, managementQueue);
   connection.start();
   Message message = session.createMessage();
   JMSManagementHelper.putAttribute(message, "jms.queue.exampleQueue", "messageCount");
   Message reply = requestor.request(message);
   int count = (Integer)JMSManagementHelper.getResult(reply);
   System.out.println("There are " + count + " messages in exampleQueue");
      </programlisting>
      <section>
         <title>Configuring JMS Management</title>
         <para>Whether JMS or the core API is used for management, the configuration steps are the
            same (see <xref linkend="management.core.configuration"/>).</para>
      </section>
      <section>
         <title>Example</title>
         <para>See <xref linkend="examples.management"/> for an example which shows how to use JMS
            messages to manage HornetQ server.</para>
      </section>
   </section>
 
   <section id="management.notifications">
      <title>Management Notifications</title>
      <para>HornetQ emits <emphasis>notifications</emphasis> to inform listeners of potentially
         interesting events (creation of new resources, security violation, etc.).</para>
      <para>These notifications can be received by 3 different ways:</para>
      <itemizedlist>
         <listitem>
            <para>JMX notifications</para>
         </listitem>
         <listitem>
            <para>Core messages</para>
         </listitem>
         <listitem>
            <para>JMS messages</para>
         </listitem>
      </itemizedlist>
      <section>
         <title>JMX Notifications</title>
         <para>If JMX is enabled (see <xref linkend="management.jmx.configuration"/>), JMX
            notifications can be received by subscribing to 2 MBeans:</para>
         <itemizedlist>
            <listitem>
               <para><literal>org.hornetq:module=Core,type=Server</literal> for notifications on
                     <emphasis>Core</emphasis> resources</para>
            </listitem>
            <listitem>
               <para><literal>org.hornetq:module=JMS,type=Server</literal> for notifications on
                     <emphasis>JMS</emphasis> resources</para>
            </listitem>
         </itemizedlist>
      </section>
      <section>
         <title>Core Messages Notifications</title>
         <para>HornetQ defines a special <emphasis>management notification address</emphasis>. Core
            queues can be bound to this address so that clients will receive management
            notifications as Core messages</para>
         <para>A Core client which wants to receive management notifications must create a core
            queue bound to the management notification address. It can then receive the
            notifications from its queue.</para>
         <para>Notifications messages are regular core messages with additional properties
            corresponding to the notification (its type, when it occurred, the resources which were
            concerned, etc.).</para>
         <para>Since notifications are regular core messages, it is possible to use message
            selectors to filter out notifications and receives only a subset of all the
            notifications emitted by the server.</para>
         <section id="management.notifications.core.configuration">
            <title>Configuring The Core Management Notification Address</title>
            <para>the management notification address to receive management notifications is
               configured in <literal>hornetq-configuration.xml</literal>:</para>
            <programlisting>
               &lt;management-notification-address&gt;hornetq.notifications&lt;/management-notification-address&gt;
            </programlisting>
            <para>By default, the address is <literal>hornetq.notifications</literal>.</para>
         </section>
      </section>
      <section>
         <title>JMS Messages Notifications</title>
         <para>HornetQ's notifications can also be received using JMS messages.</para>
         <para>It is similar to receiving notifications using Core API but an important difference
            is that JMS requires a JMS Destination to receive the messages (preferably a
            Topic):</para>
         <programlisting>
   Topic notificationsTopic = HornetQJMSClient.createHornetQTopic("hornetq.notifications", "hornetq.notifications");
         </programlisting>
         <para>Once the notification topic is created, you can receive messages from it or set a
               <literal>MessageListener</literal>:</para>
         <programlisting>
   Topic notificationsTopic = HornetQJMSClient.createHornetQTopic("hornetq.notifications", "hornetq.notifications");

   Session session = ...
   MessageConsumer notificationConsumer = session.createConsumer(notificationsTopic);
      notificationConsumer.setMessageListener(new MessageListener()
      {
         public void onMessage(Message notif)
         {
            System.out.println("------------------------");
            System.out.println("Received notification:");
            try
            {
               Enumeration propertyNames = notif.getPropertyNames();
               while (propertyNames.hasMoreElements())
               {
                  String propertyName = (String)propertyNames.nextElement();
                  System.out.format("  %s: %s\n", propertyName, notif.getObjectProperty(propertyName));
               }
            }
            catch (JMSException e)
            {
            }
            System.out.println("------------------------");
         }            
      });            
         </programlisting>
      </section>
      <section>
         <title>Example</title>
         <para>See <xref linkend="examples.management-notifications"/> for an example which shows
            how to use a JMS <literal>MessageListener</literal> to receive management notifications
            from HornetQ server.</para>
      </section>
   </section>
   <section id="management.message-counters">
      <title>Message Counters</title>
      <para>Message counters can be used to obtain information on queues <emphasis>over
            time</emphasis> as HornetQ keeps a history on queue metrics.</para>
      <para>They can be used to show <emphasis>trends</emphasis> on queues. For example, using the
         management API, it would be possible to query the number of messages in a queue at regular
         interval. However, this would not be enough to know if the queue is used: the number of
         messages can remain constant because nobody is sending or receiving messages from the queue
         or because there are as many messages sent to the queue than messages consumed from it. The
         number of messages in the queue remains the same in both cases but its use is widely
         different.</para>
      <para>Message counters gives additional information about the queues:</para>
      <itemizedlist>
         <listitem>
            <para><literal>count</literal></para>
            <para>The <emphasis>total</emphasis> number of messages added to the queue since the
               server was started</para>
         </listitem>
         <listitem>
            <para><literal>countDelta</literal></para>
            <para>the number of messages added to the queue <emphasis>since the last message counter
                  update</emphasis></para>
         </listitem>
         <listitem>
            <para><literal>depth</literal></para>
            <para>The <emphasis>current</emphasis> number of messages in the queue</para>
         </listitem>
         <listitem>
            <para><literal>depthDelta</literal></para>
            <para>The <emphasis>overall</emphasis> number of messages added/removed from the queue
                  <emphasis>since the last message counter update</emphasis>. For example, if
                  <literal>depthDelta</literal> is equal to <literal>-10</literal> this means that
               overall 10 messages have been removed from the queue (e.g. 2 messages were added and
               12 were removed)</para>
         </listitem>
         <listitem>
            <para><literal>lastAddTimestamp</literal></para>
            <para>The timestamp of the last time a message was added to the queue</para>
         </listitem>
         <listitem>
            <para><literal>udpateTimestamp</literal></para>
            <para>The timestamp of the last message counter update</para>
         </listitem>
      </itemizedlist>
      <section id="configuring.message.counters">
         <title>Configuring Message Counters</title>
         <para>By default, message counters are disabled as it might have a small negative effect on
            memory.</para>
         <para>To enable message counters, you can set it to <literal>true</literal> in <literal
               >hornetq-configuration.xml</literal>:</para>
         <programlisting>
&lt;message-counter-enabled&gt;true&lt;/message-counter-enabled&gt;
         </programlisting>
         <para>Message counters keeps a history of the queue metrics (10 days by default) and
            samples all the queues at regular interval (10 seconds by default). If message counters
            are enabled, these values should be configured to suit your messaging use case in
               <literal>hornetq-configuration.xml</literal>:</para>
         <programlisting>
&lt;!-- keep history for a week --&gt;
&lt;message-counter-max-day-history&gt;7&lt;/message-counter-max-day-history&gt;            
&lt;!-- sample the queues every minute (60000ms) --&gt;
&lt;message-counter-sample-period&gt;60000&lt;/message-counter-sample-period&gt;
         </programlisting>
         <para>Message counters can be retrieved using the Management API. For example, to retrieve
            message counters on a JMS Queue using JMX:</para>
         <programlisting>
// retrieve a connection to HornetQ's MBeanServer
MBeanServerConnection mbsc = ...
JMSQueueControlMBean queueControl = (JMSQueueControl)MBeanServerInvocationHandler.newProxyInstance(mbsc,
   on,
   JMSQueueControl.class,
   false);
// message counters are retrieved as a JSON String                                                                                                      
String counters = queueControl.listMessageCounter();
// use the MessageCounterInfo helper class to manipulate message counters more easily
MessageCounterInfo messageCounter = MessageCounterInfo.fromJSON(counters);         
System.out.format("%s message(s) in the queue (since last sample: %s)\n",
   counter.getDepth(),
   counter.getDepthDelta());
         </programlisting>
      </section>
      <section>
         <title>Example</title>
         <para>See <xref linkend="examples.message-counters"/> for an example which shows how to use
            message counters to retrieve information on a JMS <literal>Queue</literal>.</para>
      </section>
   </section>
</chapter>
